# Outline

What is cryptography?

Sending messages without someone in the middle be able to read them.

Assumes that someone in the middle can read the encrypted text:

- Wifi
- Radio
- Intercepted messenger

Someone in the middle *should not* be able to forge valid messages

Steganography - Concealing messages

- Grape juice on paper
- First letter of each paragraph
- Hidden text in PNG's

Symmetric cryptography: Apply a transformation to a message. Sender reverses it.

Example: rot13. The key is "13".

Example: shared text. You and your friend agree on a shared text, use it for
encryption/decryption.

Example: enigma. Key is the initial setting.

Extreme example: one time pads. SIGSALY: a recording system.

Nowadays: stream ciphers. Inputs are:

- a secret key
- a nonce
- the block "counter", which increments by one each 64 bytes.

What is a nonce? Without it, the ciphertext generated by a given key would be
identical for every encryption attempt. Imagine SIGSALY but with the same
recording twice; you could subtract the recordings from each other and get the
voices talking over each other.

However: **what if you want to accept messages from anyone?** You can't
communicate a secret, or one time pad, ahead of time.

Public key cryptography: I have a public key and a private key. Here's my public
key. You have a public key and a private key. I see your public key. **that's
all we need!** I can decrypt messages you send me with your public key and my
private key.

A: SK_a                  B: SK_b
A: PK_a = f(SK_a)        B: PK_b = f(SK_b)
SHK = g(SK_a, f(SK_b))   SHK = g(SK_b, f(SK_a))

The key math points are:

1) `g(A secret, B public)` and `g(B secret, A public)` produce the same value
2) it's hard to reverse `f`, so computing a secret if you have a public key is difficult.

There are a few different functions for f and g. Elliptic curve cryptography
depends on integer values for logarithms being hard to find. Expressed another
way:

    3^k â‰¡ 13 (mod 17)

Generally, it's hard to find k. (In this easy case, 4 is a solution). Current
best solutions involve increasing values of k and doing the multiplication and
seeing if it solves the constraints.

Generally this is called "elliptic curve cryptography". Curve25519 is
a particular choice for the elliptic curves.

Why curve25519? A few reasons.

### Misuse resistance.

Which way does this door open?

Which way does this door open?

Consequences can be tragic. Victoria Hall: "Free Toys" at a kids show.

1100 kids rush down the stairs to get to the stage. Door opened toward them,
only wide enough for one child at a time to get through.

Prone to misuse: JWT. RSA point validation.

Curve25519: every arrangement of 32 bytes is a valid private key.

1) Generate 32 bytes of random data
2) byte[0] = byte[0] & 248
3) byte[31] = byte[31] & 127
4) byte[31] = byte[31] | 64

That's it! Then generate a public key.

### Speed

Curve25519 is really fast. The floating point math to compute this curve works
well with Intel registers.
